import z3
from typing import Optional

from core.schemas import ValidationResult
# No longer need parsing types here

class Z3CodeExecutionError(ValueError):
    """Custom exception for errors during execution of generated Z3 code."""
    pass

def validate_proof_with_z3(z3_code_str: str) -> ValidationResult:
    """
    Validates a theorem by executing Z3 Python code generated by Claude.

    1. Executes the provided `z3_code_str` which should define a Z3 assertion 
       variable named `z3_assertion`.
    2. Adds the negation of this `z3_assertion` to a Z3 solver.
    3. Checks if the negation is unsatisfiable (meaning the original theorem is valid).

    Args:
        z3_code_str: A string containing Python code using the z3-solver library.

    Returns:
        A ValidationResult indicating validity and details.
    """
    solver = z3.Solver()
    details = [f"Attempting to execute Z3 code:\n---\n{z3_code_str}\n---"]
    local_exec_env = {}

    try:
        # 1. Execute the generated Z3 code string
        # We provide z3 module in the global context for the code to use
        exec(z3_code_str, {'z3': z3}, local_exec_env)
        
        # 2. Check if the expected assertion variable was created
        if 'z3_assertion' not in local_exec_env:
            raise Z3CodeExecutionError("Generated code did not define 'z3_assertion' variable.")
            
        z3_assertion = local_exec_env['z3_assertion']
        if not isinstance(z3_assertion, (z3.ExprRef, z3.BoolRef)):
             raise Z3CodeExecutionError(f"'z3_assertion' is not a valid Z3 expression type, got {type(z3_assertion)}.")

        details.append(f"Successfully executed code. Assertion: {z3_assertion}")

        # 3. Add negation to solver and check
        negated_theorem = z3.Not(z3_assertion)
        solver.add(negated_theorem)
        details.append(f"Checking satisfiability of: Not(assertion)")

        result = solver.check()
        details.append(f"Z3 Result: {result}")

        if result == z3.unsat:
            return ValidationResult(is_valid=True, details="\n".join(details))
        elif result == z3.sat:
            try:
                model = solver.model()
                details.append(f"Counter-example (model for negation): {model}")
            except z3.Z3Exception:
                details.append("Could not retrieve model.")
            return ValidationResult(is_valid=False, details="\n".join(details))
        else: # result == z3.unknown
            details.append("Z3 could not determine satisfiability (unknown).")
            return ValidationResult(is_valid=False, details="\n".join(details))

    except (Z3CodeExecutionError, SyntaxError, NameError, TypeError, z3.Z3Exception) as e:
        details.append(f"Error during Z3 code execution or validation: {e}")
        return ValidationResult(is_valid=False, details="\n".join(details))
    except Exception as e:
        details.append(f"Unexpected validation error: {e}")
        return ValidationResult(is_valid=False, details="\n".join(details))

# Example Usage (for testing)
if __name__ == '__main__':
    # Requires core.schemas to be importable
    print("Running validator tests...")
    
    test_cases = [
        # Valid Z3 Python code defining z3_assertion
        "import z3\nx = z3.Int('x')\nz3_assertion = (x == x)",
        "import z3\nx = z3.Int('x')\ny = z3.Int('y')\nz3_assertion = z3.ForAll([x], z3.Exists([y], y > x))",
        # Invalid - doesn't define z3_assertion
        "import z3\nx = z3.Int('x')\nresult = (x > 5)",
        # Invalid - syntax error
        "import z3\nx = z3.Int('x'\nz3_assertion = x",
        # Valid Z3 code for an invalid theorem (negation is SAT)
        "import z3\nx = z3.Int('x')\nz3_assertion = (x > 5)"
    ]

    for i, code in enumerate(test_cases):
        print(f"--- Test Case {i+1} ---")
        print(f"Input Code:\n{code}")
        result = validate_proof_with_z3(code)
        print(f"Validation Result: {result}")
        print("---------------------") 